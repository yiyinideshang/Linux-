# 10.5网络编程相关信号

# 10.5.1 	`SIGHUP`：控制终端挂起

# 10.5.2 `SIGPIPE`：往读端被关闭的管道或者socket连接中写数据

## 1. 什么是 `SIGPIPE` 信号

- **定义**：当进程向一个**对端读端已经关闭**（即数据接收方不再接收数据）的管道（`Pipe`）或 `Socket` 连接中写入数据时，操作系统会向该进程发送 `SIGPIPE` 信号。
- **默认行为**：收到 `SIGPIPE` 的进程会**直接终止**。
- **目的**：防止数据被写入到永远无法被读取的“黑洞”，避免进程阻塞和资源浪费，并及时通知程序连接已破裂。

## 2. 理解“读端关闭”

“读端关闭”指的是**数据接收方不再从通道中读取数据**，即对端的读端已被关闭。由于管道和 Socket 的通信模型不同，需要分别理解：

- **管道（单向通信）**：只有一个读端和一个写端。读端关闭意味着整个通道失效，写端再写入就会触发 `SIGPIPE`。
  **符号表示**：`A读(✘) ← B写`（A 关闭读端，B 写触发 `SIGPIPE`）
- **Socket（全双工）**：有两个独立的数据流。`SIGPIPE` 的触发条件是**对端的读端关闭**，即本端写入时数据无法送达对端。
  **符号表示**：`A读(✘) ← B写`（A 关闭读端，B 写触发 `SIGPIPE`）

## 3. 所有关闭场景详细分析

下表涵盖了管道和 Socket 中所有可能的关闭情况，并说明了写操作是否触发 `SIGPIPE` 以及 `poll`/`epoll` 会触发什么事件（`EPOLL` 事件类似，此处以 `poll` 为例）。

| 类型       | 关闭动作（谁关闭了什么）                 | 符号表示                                       | 本端写操作是否触发 `SIGPIPE`（谁写）                         | `poll`/`epoll` 事件（哪个描述符，什么事件，是否需要注册）    |
| :--------- | :--------------------------------------- | :--------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **管道**   | 读端关闭（A 关闭读端）                   | `A读(✘) ← B写`                                 | **B 写触发 `SIGPIPE`**                                       | **B 写端**：`POLLHUP`（条件事件，无需注册）                  |
| **管道**   | 写端关闭（B 关闭写端）                   | `A读 ← B写(✘)`                                 | B 写端已关闭，若 B 再写则触发 `SIGPIPE`（自身写端关闭）      | **A 读端**：先 `POLLIN`（若有剩余数据），数据读完后再触发 `POLLHUP`（条件事件） |
| **Socket** | 对端关闭读端（**B 关闭读端**）           | A写 → B读(✘)                                   | **A 写触发 `SIGPIPE`**                                       | **A 写端**：无直接 `poll` 事件。写操作导致对端 `RST` 后，后续可能触发 `POLLERR` 或 `POLLHUP`。 |
| **Socket** | 对端关闭写端（**B 关闭写端**）（半关闭） | `A读 ← B写(✘)`                                 | A 写不受影响（除非 B 也关闭读端）<br />B 写端已关，若 B 再写则触发 `SIGPIPE` | **A 读端**：若注册 `POLLRDHUP`，则触发 `POLLRDHUP`；否则只触发 `POLLIN`（可读且 `read` 返回 0） |
| **Socket** | 对端完全关闭（**B 关闭读写两端**）       | B 读写均关<br />A读 ← B写(✘)<br />A写 → B读(✘) | **A 写触发 `SIGPIPE`**                                       | **A 端**：`POLLHUP` 或 `POLLERR`（条件事件，无需注册）       |
|            |                                          |                                                |                                                              |                                                              |
| **Socket** | 本端关闭读端（**A 关闭读端**）           | `A读(✘) ← B写`（即 B 写 → A 读，A 读端关闭）   | **B 写触发 `SIGPIPE`**（对称于对端关闭读端）                 | **B 写端**：无直接 `poll` 事件，写后可能触发 `POLLERR`       |
| **Socket** | 本端关闭写端（**A 关闭写端**）（半关闭） | `A写(✘) → B读`                                 | B 写不受影响（除非 A 也关闭读端）<br />A 写端已关，若 A 再写则触发 `SIGPIPE`（对称于对端关闭写端） | **B 读端**：若注册 `POLLRDHUP`，则触发 `POLLRDHUP`；否则只触发 `POLLIN`（可读且 `read` 返回 0） |

**说明**：

- `POLLHUP` 是条件事件：即使未在 `events` 中注册，只要**描述符处于挂起状态**（如**管道读端关闭**或 **Socket 完全断开**），`revents` 中就会包含它。
- `POLLRDHUP` 需要显式注册，仅适用于 Socket，表示**对端关闭了写通道**（本端读通道关闭）。
- 管道不支持 `POLLRDHUP`，即使注册也无效。

## 4. 为什么需要 `SIGPIPE`？

- 避免进程无限阻塞：若对端读端已关闭，`write()` 将永远无法成功，可能导致进程卡死。
- 防止内核缓冲区堆积无效数据，浪费系统资源。
- 提供主动错误通知，让进程及时感知连接失效。

## 5. 处理 `SIGPIPE` 的常见方式

默认行为终止进程，在网络编程中通常需要更优雅的处理：

### 	5.1 忽略或捕获信号

```c
#include <signal.h>
signal(SIGPIPE, SIG_IGN);   // 忽略信号
```

或自定义处理函数，信号被忽略或捕获后，`write()`/`send()` 会返回 -1 并设置 `errno` 为 `EPIPE`（Broken pipe）。

### 	5.2 使用 `MSG_NOSIGNAL` 标志（`Linux`）

```c
ssize_t ret = send(sockfd, buf, len, MSG_NOSIGNAL);
if (ret == -1 && errno == EPIPE) {
    // 连接已断开
}
```

### 	5.3 使用 `SO_NOSIGPIPE` 选项（`macOS` 等）

在 socket 上设置该选项，使写操作不产生 `SIGPIPE`。

## 6. 注意事项

### 	6.1. 为什么 `POLLRDHUP` 不适用于管道？

- **设计定位**：`POLLRDHUP` 是专门为 socket 引入的，对应 TCP 协议层面的 FIN 包。管道是基于文件系统的简单流，没有半关闭概念，因此内核不会为管道产生 `POLLRDHUP` 事件。
- **即使注册也会被忽略**：在管道文件描述符上注册 `POLLRDHUP` 是无效的，`poll` 永远不会在 `revents` 中返回它。

### 	6.2. 关于显式注册

- **`POLLHUP`（poll）和 `EPOLLHUP`（`epoll`）属于“条件事件”**
  即使你在 `events` 中没有显式设置它们（例如只注册了 `POLLIN`），当条件满足时（如管道的读端关闭），`revents` 中依然会包含 `POLLHUP`（或 `EPOLLHUP`）。这是由内核自动检测并报告的。
  - **原因**：`POLLHUP` 表示文件描述符发生了“挂起”，这种状态对程序至关重要（例如管道破裂后写入会失败），因此内核总是会通知应用程序，无论你是否主动要求监听。

- **`POLLRDHUP`（poll）和 `EPOLLRDHUP`（`epoll`）需要显式注册**
  你必须在 `events` 中明确包含 `POLLRDHUP` 或 `EPOLLRDHUP`，内核才会在对方关闭写端（发送 FIN）时通知你。如果不注册，即使发生了该事件，`revents` 中也不会出现这些标志，你只能通过读取返回 0 来间接发现。
  - **仅适用于 socket**
    这些事件是 Linux 为 socket 引入的扩展，用于精确表示 TCP 的半关闭状态（对端关闭写端，即本端读通道关闭）。管道或其他文件类型不支持此事件，即使注册了也会被忽略


| 事件                       | 是否需要显式注册       | 适用对象                | 语义                                                |
| :------------------------- | :--------------------- | :---------------------- | :-------------------------------------------------- |
| `POLLHUP` / `EPOLLHUP`     | **不需要**（条件事件） | 通用（管道、socket 等） | 连接挂起（如**管道读端关闭**、**socket 完全断开**） |
| `POLLRDHUP` / `EPOLLRDHUP` | **必须显式注册**       | 仅 socket               | 仅表示另一端 关闭了写端                             |

- **socket 完全断开**：当双方都关闭写端（或收到 `RST`）时，连接彻底失效，此时触发 `POLLHUP`，而不是 `POLLRDHUP`。

# 10.5.3 `SIGURG`

在Linux环境下，内核通知应用程序带外数据到达主要有两种方法：

- 一种方法是：第9章介绍的I/O复用技术，`select`等系统调用在接收到带外数据时将返回，并向应用程序报告socket上的异常事件==参见代码清单9-1==

## 代码清单9-1 同时接收普通数据和带外数据和代码清单5-6的组合作用

### 	==代码清单9-1== 同时接收普通数据和带外数据

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>
#include <libgen.h>
#include <sys/select.h>

int main(int argc,char* argv[])
{
    if(argc<=2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi(argv[2]);

    int ret = 0;
    struct sockaddr_in address;
    bzero(&address,sizeof(address));
    address.sin_family = AF_INET;
    inet_pton(AF_INET,ip,&address.sin_addr);
    address.sin_port = htons(port);

    int listenfd = socket(PF_INET,SOCK_STREAM,0);
    assert(listenfd>=0);
    ret = bind(listenfd,(struct sockaddr*)&address,sizeof(address));
    assert(ret != -1);
    ret = listen(listenfd,5);
    assert(ret != -1);

    struct sockaddr_in client_address;
    socklen_t client_addresslength = sizeof(client_address);
    int connfd = accept(listenfd,(struct sockaddr*)&client_address,&client_addresslength);

    if(connfd<0)
    {
        printf("errno is:%d\n",errno);
        close(connfd);
    }


    char buf[1024];
    fd_set  read_fds;
    fd_set exception_fds;
    FD_ZERO(&read_fds);
    FD_ZERO(&exception_fds);

    while(1)
    {
        memset(buf,'\0',sizeof(buf));
        //每次调用select前，都要重新再read_fds和exception_fds中设置文件描述符connfd,因为事件发生之后，文件描述符集合将被内核修改。
        FD_SET(connfd,&read_fds);
        FD_SET(connfd,&exception_fds);
        ret = select(connfd+1,&read_fds,NULL,&exception_fds,NULL);
        if(ret < 0)
        {
            printf("selection failure\n");
            break;
        }

        //对于异常事件，采用带MSG_OOB标记的recv读取带外数据
        if(FD_ISSET(connfd,&exception_fds))
        {
            ret = recv(connfd,buf,sizeof(buf)-1,MSG_OOB);
            if(ret <= 0)
            {
                break;
            }
            printf("get %d bytes of oob data:%s\n",ret,buf);
        }
        //对于可读事件，采用普通的recv函数读取数据
        else if(FD_ISSET(connfd,&read_fds))
        {
            ret = recv(connfd,buf,sizeof(buf)-1,0);
            if(ret <= 0)
            {
                break;
            }
            printf("get %d bytes of normal data:%s\n",ret,buf);
        }
        
    }
    close(connfd);
    close(listenfd);
}
```

这段代码是使用 **I/O 复用（select 模型）** 来处理 TCP 带外数据的另一种方式，与之前使用 `SIGURG` 信号的异步方法不同。它通过 `select` 同时监视套接字的普通可读事件和异常事件，从而区分普通数据和带外数据。

- ## 代码作用

1. **创建监听套接字**，绑定地址并监听，接受一个客户端连接。
2. **进入循环**，每次迭代：
   - 将已连接套接字 `connfd` 分别加入 `read_fds`（读集合）和 `exception_fds`（异常集合）。
   - 调用 `select` 阻塞，直到有事件发生。
   - 当 `select` 返回后，通过 `FD_ISSET` 判断哪个集合就绪：
     - 如果 `connfd` 在 `read_fds` 中就绪，则用普通 `recv`（无标志）读取数据，视为普通数据。
     - 如果 `connfd` 在 `exception_fds` 中就绪，则用 `recv` 的 `MSG_OOB` 标志读取带外数据。
3. **循环直到连接关闭或出错**，然后关闭套接字。

- ## 与 `SIGURG` 方法的区别

  - **检测机制**：

    - `SIGURG` 依赖信号异步通知，需要设置套接字属主并注册信号处理函数。
    - `select` 通过异常事件集合同步检测，程序主动调用 `select` 等待。

    - **优缺点**：
      - 信号方式可能被打断，处理函数需注意异步安全性；`select` 方式更可控，但需要循环调用。
      - `select` 可以同时处理多个文件描述符，而信号方式每个连接需单独设置属主。

  - 另一种方法是：使用`SIGURG`信号==参见代码清单10-3==

### 运行结果分析

**客户端**：

```bash
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ gcc -o 5-6发送带外数据 5-6发送带外数据.c 
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ ./5-6发送带外数据 127.0.0.1 8888
```

**服务端**：

```bash
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ gcc -o 9-1同时处理普通数据和带外数据 9-1同时处理普通数据和带外数据.c 
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ ./9-1同时处理普通 数据和带外数据 127.0.0.1 8888
get 1 bytes of oob data:c
get 5 bytes of normal data:123ab
get 3 bytes of normal data:123
```

## 代码清单10-3 和代码清单5-6的组合作用

### 	==代码清单10-3== 用`SIGURG`检测带外数据是否到达——服务器接收来自客户端的数据

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <fcntl.h>
#include <libgen.h>

#define BUF_SIZE 1024

static int connfd;
//SIGURG信号的处理函数
void sig_urg(int sig)
{
    int save_errno = errno;
    char buffer[BUF_SIZE];
    memset(buffer,'\0',BUF_SIZE);
    int ret = recv(connfd,buffer,BUF_SIZE-1,MSG_OOB);//接受带外数据
    printf("got %d bytes of oob data '%s'\n",ret,buffer);
    fflush(stdout);
    errno = save_errno;
}

//设置信号处理函数
void addsig(int sig,void(*sig_handler)(int))
{
    struct sigaction sa;
    memset(&sa,'\0',sizeof(sa));
    sa.sa_handler = sig_handler;//注册信号处理函数
    sa.sa_flags |= SA_RESTART;//自动重启被信号中断的系统调用
    sigfillset(&sa.sa_mask);//执行处理函数时，阻塞所有信号
    assert(sigaction(sig,&sa,NULL) != -1);
}

int main(int argc,char* argv[])
{
    if(argc <= 2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi(argv[2]);

    struct sockaddr_in address;
    bzero(&address,sizeof(address));
    address.sin_family = AF_INET;
    inet_pton(AF_INET,ip,&address.sin_addr);
    address.sin_port = htons(port);

    int sock = socket(PF_INET,SOCK_STREAM,0);
    assert(sock>=0);

    int ret = bind(sock,(struct sockaddr*)&address,sizeof(address));
    assert(ret != -1);

    ret = listen(sock,5);
    assert(ret != -1);

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof(client);
    connfd = accept(sock,(struct sockaddr*)&client,&client_addrlength);
    if(connfd<0)
    {
        printf("errno is:%d\n",errno);
    }
    else
    {
        addsig(SIGURG,sig_urg);
        //使用SIGURG信号前，必须设置socket的宿主进程或进程组
        if (fcntl(connfd, F_SETOWN, getpid()) == -1) 
        {
            perror("fcntl F_SETOWN");
            // 处理错误
        }

        char buffer[BUF_SIZE];
        while(1)
        {
            memset(buffer,'\0',BUF_SIZE);
            ret = recv(connfd,buffer,BUF_SIZE-1,0);
            if(ret <= 0)
            {
                break;
            }
            printf("got %d bytes of normal data '%s'\n",ret,buffer);
        }
        
        close(connfd);
    }
    close(sock);
    return 0;
}
```

运行该程序，然后使用**代码清单5-6**所描述的客户端程序来往该服务器程序发送数据，以观察服务器是如何同时处理普通数据和带外数据的。

### 	==代码清单5-6==	发送带外数据——客户端发送数据到服务器

```c
#include <string.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <fcntl.h>
#include <libgen.h>

int main(int argc,char* argv[])
{
	if(argc<=2)
	{
		printf("usage:%s ip_address port_number\n",basename(argv[0]));
		return 1;
	}
	const char* ip = argv[1];
	int port = atoi(argv[2]);
	
	struct sockaddr_in server_address;
	bzero(&server_address,sizeof(server_address));
	server_address.sin_family = AF_INET;
	inet_pton(AF_INET,ip,&server_address.sin_addr);
	server_address.sin_port = htons(port);
	
	int sockfd = socket(PF_INET,SOCK_STREAM,0);
	assert(sockfd>=0);
	if(connect(sockfd,(struct sockaddr*)&server_address,sizeof(server_address))<0)
		printf("coonnection failed\n");
	else
	{
		const char* oob_data = "abc";
		const char* normal_data = "123";
		send(sockfd,normal_data,strlen(normal_data),0);
		send(sockfd,oob_data,strlen(oob_data),MSG_OOB);
        send(sockfd,normal_data,strlen(normal_data),0);
    }
    close(sockfd);
    return 0;
}
```

这两个代码协同演示了**TCP带外数据（Out-of-Band Data）的发送与接收**，并利用 **SIGURG信号** 实现异步处理。服务器端使用信号机制检测带外数据的到达，客户端则分别发送普通数据和带外数据。

- ## 服务器端（使用 SIGURG 检测带外数据）

  - 创建监听套接字，绑定地址并监听。

  - 接受客户端连接后，将连接套接字设为当前进程的属主（`fcntl(connfd, F_SETOWN, getpid())`），以便带外数据到达时内核发送 `SIGURG` 信号。

  - 注册 `SIGURG` 信号处理函数 `sig_urg`，该函数通过 `recv` 的 `MSG_OOB` 标志读取带外数据并打印。

  - 主循环中持续接收普通数据（`recv` 不带标志），并打印接收到的普通数据及其长度。

  - 当连接关闭或出错时退出。


- ## 客户端（发送普通数据和带外数据）

  - 根据命令行参数连接服务器。
    - 依次发送：
      - 第一个普通数据 `"123"`（长度3）；
      - 带外数据 `"abc"`，但发送时**必须**使用 `MSG_OOB` 标志，根据 TCP 协议，只有最后一个字节 `'c'` 被真正作为带外数据，前两个字节 `'a'` 和 `'b'` 会作为普通数据进入流；
      - 第二个普通数据 `"123"`（长度3）。


  - 发送完成后关闭连接。


### 运行结果分析：

**客户端**：

```bash
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ gcc -o 5-6发送带外数据 5-6发送带外数据.c 
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ ./5-6发送带外数据 127.0.0.1 8888
```

**服务端**：

> 注意：由于 Linux TCP 的 OOB 实现特性，更好的做法是**不依赖 `SIGURG`**，而是使用 `select/poll` 的异常条件检测
>
> 服务端运行结果可能没有	got 1 bytes of oob data 'c'

```bash
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ gcc -o 10-3用SIGURG检测带外数据 10-3用SIGURG检测带外数据.c 
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ ./10-3用SIGURG检测带外数据 127.0.0.1 8888
got 1 bytes of oob data 'c'
got 5 bytes of normal data '123ab'
got 3 bytes of normal data '123'
```

这个结果表明：

1. **外数据仅最后一个字节被特殊处理**：
   客户端发送带外数据 `"abc"`（`MSG_OOB`），实际只有字符 `'c'` 被标记为紧急数据，而 `'a'` 和 `'b'` 被当作普通数据放入接收缓冲区。因此信号处理函数 `sig_urg` 通过 `recv(..., MSG_OOB)` 只读取到了 `'c'`，输出为 `got 1 bytes of oob data 'c'`。
2. **普通数据与带外数据分离接收**：
   - 第一次普通接收 `recv` 得到 `"123ab"`（共5字节）：这是客户端发送的第一个普通数据 `"123"` 和带外数据的前两个字节 `"ab"` 的合并结果。由于 TCP 是流协议，这些普通数据可能被一起接收。
   - 第二次普通接收得到 `"123"`（共3字节）：即客户端最后发送的普通数据。
3. **信号触发时机**：
   带外数据到达时，内核立即发送 `SIGURG` 信号，信号处理函数抢在普通数据接收之前执行（也可能在之后，取决于调度）。本例中信号处理函数先被调用，因此先打印了带外数据，随后主循环才接收普通数据。无论顺序如何，带外数据始终被单独提取，不会混入普通数据流。

## 与代码清单5-7和代码清单5-6的组合作用

> ## 与代码清单5-7和代码清单5-6的组合结果一致，只是输出结果可能为：
>
> ```c
> got 5 bytes of normal data '123ab'
> got 1 bytes of oob data 'c'
> got 3 bytes of normal data '123'
> ```

## 梳理总结

3-8节介绍了TCP带外数据的基本知识，其中探讨了TCP模块是如何发送和接收带外数据的。==参看5Linux网络编程基础API.md、50-51页==

5.8.1小节描述了如何在应用程序中使用带`MSG_OOB`标志的`send`/`recv`系统调用来发送/接收带外数据，并给出了相关代码。==参见	代码清单5-6、代码清单 5-7==

9.1.3小节和10.5.3小节分别介绍了检测带外数据是否到达的两种方法：I/O复用系统调用报告的异常事件和`SIGURG`信号  ==参见	代码清单9-1、代码清单10-3==

但应用程序检测到带外数据到达后，我们还需要进一步判断带外数据在数据流中的具体位置，才能够准确无误地读取带外数据。

5.9节介绍的`sockatmark`系统调用就是专门用于解决这个问题的。它判断一个socket是否处于带外标记，即该socket上下一个将被读取到的数据是否是带外数据。

